# 소개

앱 내부 저장소에서 비디오 파일을 가져와서 음성을 추출한 뒤에, 해당 음성 파일을 사용자가 원하는 언어로 번역해서 자막으로 표시하여 재생하는 기능을 제공하는 안드로이드 앱

# 세부적인 요구사항

1. 앱에는 두개의 화면 "갤러리 화면"과 "재생 화면" 으로 구성된다.
2. 앱 내부 저장소에서 비디오 파일을 가져온다.
    2-1. 안드로이드 15 버전을 타겟팅 하기 때문에 Photo picker 를 이용한다. 여러개의 비디오 파일을 가져올 수 있도록 PickMultipleVisualMedia(Integer.MaxValue) Contract 를 이용한다.
    2-2. 사용자가 photo picker 에서 가져온 비디오 파일을 갤러리 형태로 "갤러리 화면"에 노출한다.
        2-2-1. "갤러리 화면"은 가로 4칸, 세로 N칸 의 격자형으로 노출된다.
        2-2-2. 각각의 아이템(비디오 파일)은 비디오의 썸네일(첫 프레임 사진)과 제목이 노출된다.
        2-2-3. 가져온 비디오 파일이 없다면, "비어 있음" 이라는 문구를 중앙 정렬로 노출한다.
3. 사용자가 "갤러리 화면"에서 재생하고 싶은 아이템(비디오 파일)을 선택한다.
    3-1. 선택된 아이템의 자막 파일이 있는지 확인한다.
        3-1-1. 없다면, (3-1-1-1) 로 넘어간다.
            3-1-1-1. 음성의 파일 크기와 품질에 대한 적절한 오버헤드를 위해 AAC 포맷의 파일로 추출한다.
            3-1-1-2. 추출된 AAC 파일을 google cloud 의 speech-to-text api 를 활용하여 텍스트로 변환한다. 이 과정에서 각 음성의 시작시간과 끝시간이 필요하므로 매개변수의 RecognitionConfig 의 enableWordTimeOffsets 이 true 여야 한다.
            3-1-1-3. google cloud 의 translation api 를 활용하여, "사용자 지정 언어"(내부 저장소인 DataStore 에 저장된 사용자가 선택한 언어의 BCP-47 코드값)에 따라 추출된 텍스트를 번역한다.
            3-1-1-4. 시작시간 및 끝시간을 자막에서 활용 가능한 timeStamp 형식으로 변환하고, 번역된 텍스트를 기반으로 SRT 포맷의 자막파일을 생성한다. 최초 변환된 자막 파일은 외부에서 이용할 수 없도록 앱 내부 파일로 저장하고, 이후 재사용 한다. 자막 파일 이름은 파일이름과 "사용자 지정 언어" 코드값을 기반으로 다음과 같이 지정한다.(파일이름_사용자 지정 언어 코드값)
            3-1-1-5. (3-1-1-1 ~ 3-1-1-4) 과정이 오래걸릴 수 있기 때문에, Foreground Service 에서 실행한다. Notification 에서 진행 상황의 seek bar 를 노출하고, 변환이 완료되면 "변환 완료" 문구가 보여지는 새로운 Notification 을 띄워 준다. 이 새로운 Notification 을 클릭하면 (3-2) 로 넘어간다.
        3-1-2. 있다면, (3-2) 로 넘어간다.
    3-2. 선택된 비디오 파일의 "재생 화면"으로 navigate 한다. 전환시 argument 로 비디오 파일의 contentURI 를 string 타입으로 전달한다.
4. "재생 화면"으로 전환되면, 전달 받은 비디오 파일의 ContentURI 로 비디오 파일을 재생하면서 저장된 자막을 함께 노출한다.
    4-1. "재생 화면"에는 비디오, 재생 위치(seek bar), 재생 컨트롤러(이전 비디오, 중지/재생, 다음 비디오), 언어 설정 버튼이 존재한다.
        4-1-1. 비디오의 크기는 화면의 넓이에 horizontal 의 16.dp 만큼의 패딩을 제외한 크기를 갖고, 높이는 넓이에 비례한다.
        4-1-2. 재생 위치는 seek bar 로 구성된다. 재생에 따라 seek 의 위치를 변화시키며, 마찬가지로 seek bar 의 변화가 재생 지점에 영향을 미쳐야 한다.
        4-1-3. photo picker 에 의해 가져온 모든 비디오를 플레이 리스트에 삽입하고, 재생 컨트롤러에 의해 이전 혹은 다음 비디오를 재생시키거나 현재 비디오를 재생 혹은 중단시킬 수 있다.
        4-1-4. 언어 설정 버튼은 비디오 노출 부분 위에 overlay 되며, 사용자가 클릭하면 언어 설정을 위한 Menu(Compose 의 DropDownMenu) 가 노출된다.
            4-1-4-1. 메뉴에서 4개의 언어(한국어, 영어, 일본어, 중국어-간체, 중국어-번체) 를 선택할 수 있다.
            4-1-4-2. 메뉴의 아이템 선택시 "사용자 지정 언어"(내부 저장소인 DataStore 에 저장된 BCP-47 태그값) 항목을 해당 아이템의 코드값으로 수정한다. "사용자 지정 언어"의 최초 초기값으로는 Locale.getDefault() 을 사용한다.
            4-1-4-3. 사용자가 "사용자 지정 언어" 를 변경하면, "사용자 지정 언어"의 코드값과 일치하는 자막 파일이 있는지 파일 이름을 기준으로 확인한다. 만약 없다면, 존재하는 자막 파일중 하나를 기반으로 (3-1-1-3 ~ 3-1-1-4) 과정을 수행하고 생성된 자막 파일로 자막을 교체한다. 이미 존재 한다면, ExoPlayer 의 자막을 해당 자막 파일로 교체한다.

# 세부적인 기술 스택 및 아키텍처

1. 비디오 재생은 media3.exoplayer 이용한다.
    1-1. 자막은 SRT 포맷을 이용하고, 자막으로 활용하여 재생 가능한 타임 스탬프 형식으로 저장한다.
    1-2. 비디오 파일의 음성 추출은 FFmpeg 라이브러리를 이용하고, 추출된 오디오는 AAC 포맷으로 저장한다.
2. 구글 권장 아키텍처를 기반으로 ui 로직, 비즈니스 로직, 데이터 로직에 대한 관심사를 분리한다.
    2-1. 구글 권장 아키텍처는 https://developer.android.com/topic/architecture/recommendations?hl=ko 에서 참조한다.
    2-2. 도메인 레이어는 생략하며 app, features(presentation layer), data, design, build-logic 모듈이 존재한다.
        2-2-1. features:gallery 모듈에 "갤러리 화면" 이 존재하고, features:player 모듈에 "재생 화면" 이 위치한다.
            2-2-1-1. 각 features 의 내부 모듈들에 각각의 화면에 사용되는 ui 로직과 비즈니스 로직은 AAC-ViewModel 내부에 위치한다.
        2-2-2. data 모듈은 features 모듈에서 참조하는 데이터 입출력과 같은 외부 저장소 또는 내부 저장소에 접근하는 데이터 로직이 위치하는 모듈이다.
            2-2-2-1. data 에는 DataSource, Repository 패턴을 이용하며, 각각 interface 와 implementation 으로 분리한다. DataSource 에는 데이터 입출력 로직이 존재해야 하고, Repository 는 DataSource 들을 퍼사드 하여 필요한 형태의 데이터를 노출한다.
            2-2-2-2. Repository 에서 DataSource 의 하나의 입출력을 단순 포워딩 해야 한다면, DataSource 의 해당 메소드를 Repository 로 포워딩 하지 않고 ViewModel 이 직접 DataSource 를 참조하여 해당 메소드를 호출하도록 작성한다.
            2-2-2-3. data 모듈에서 각각의 Repository 와 DataSource 의 구현체들의 의존성 주입을 위해 Hilt 의 @Module 을 작성한다. 이때, @Singleton 어노테이션으로 선언하여 어플리케이션 생명주기를 따르도록 한다.
        2-2-3. design 모듈에는 features 모듈에서 참조하는 디자인 컴포넌트들을 재사용하는 목적으로 사용한다.
        2-2-4. build-logic 모듈에는 모든 프로젝트 내부 모듈에서 사용하는 빌드 로직의 재사용 목적으로 사용한다.\
        2-2-5. app 모듈에는 Activity, Application 과 전역적으로 사용되는 AdMob 과 InAppUpdate 관련 로직들을 캡슐화한 클래스, Compose-Navigation 을 관리하는 Router 등의 클래스가 존재한다.
    2-4. 데이터 로직에서 발생하는 예외는 Presentation layer 의 AAC-ViewModel 에서 처리해야 한다. 예외는 Kotlin 의 Result<T> 로 변환하여 ViewModel 에서 예외를 처리한다.
    2-5. 상태 관리의 복잡성을 줄이기 위해 ViewModel 에서는 View 가 필요한 상태를 단일 상태로 노출시킨다. View 에서 필요한 상태를 만들기 위해 필요한 여러 비즈니스 로직들을 결합한 flow 를 Flow#stateIn() 함수로 hot flow 를 생성함으로써 단일 상태를 만든다. View(Compose) 에서는 생성된 단일 상태를 collectAsStateWithLifecycle() 로 추적한다.
    2-6. design 모듈에는 compose 프레임워크를 이용하여 만들어진 재 사용 가능한 단위의 디자인 컴포넌트들이 위치한다.
3. 언어는 코틀린 언어로 작성하고, 최대한 코틀린 extension 라이브러리와 같은 코틀린 패키지의 함수들을 이용한다.
4. UI 코드는 compose 프레임워크를 이용한 composable 함수로 작성한다.
5. google cloud 의 Speech-To-Text, Translation api 는 REST API 를 이용하며, api key 는 local.properties 에 명시되어 있다. (Retrofit2의 interceptor 에서 BuildConfig 를 통해 api key 를 가져와 header 에 삽입하고 있는 코드를 참조)
6. 의존성 주입은 Jetpack 의 hilt 를 이용한다.
7. 비동기 코드 작성은 kotlin 의 Coroutines 를 활용한다. 일회성 이벤트는 suspend 함수를 이용하고, 스트림이 필요한 경우 Coroutines.Flow 를 이용한다.

# 코드 작성 시 유의사항

1. 기존 파일의 모든 코드를 최대한 이용하여 코드를 작성한다.
2. 모든 제네릭의 타입 파라미터를 포함한 타입은 가독성을 위해 Any 가 되어서는 안된다. 필요한 경우 enum 또는 sealed 클래스 등을 생성하여 타입을 명시해 주어야 한다.